/*!

\page protocol_flow Protocol flow

\brief 

\author M.K.A. <wyrmchild@users.sourceforge.net>

\section login Login

Client sends protocol identifier, server responds with host info, client
replies with user info, and server returns the user info with missing information filled in.

More in-depth explanation follows:

1. Client connects to server and sends the protocol identifier (protocol::Identifier)
and waits for response.
- If the identifier was invalid, the connection is dropped by server.
- If the server is password protected, the server will send authentication
request (protocol::Authentication) to which the client must respond with correct
password (protocol::Password) before login process may continue. Server is free to
send error on invalid password or disconnect the client.

2. If the identifier was valid and the client responded with correct password
(if it was requested), the server will reply with host info (protocol::HostInfo)
message.

3. Client must respond with user info, with user event set to login, and user name
set if such is required by server.
- If the user info does not match the server's requirements, the server is free to send
an error message or disconnect the user.
- If the user info is valid, the server must fill out the missing pieces
(user ID and mode) and send it back to the user, the name field may be emptied
to save bandwidth, since the client should know its username already
(it was the one to provide it).

4. Client should be deemed logged in at the moment the client receives the user info back.

\todo Make this section less confusing.

\section drawing Drawing

Tool info describes the tool used for drawing. Stroke info describes
the stroke, or the path which was taken to draw the line, and the applied pressure (set to
max if the device used does not support pressure). Stroke end is to announce the end
of a line, the point at which the mouse button was de-pressed or the stylus lifted.

- Tool info message precedes any stroke info or stroke end when the tool is not
already described.
- Since only one tool can be described at a time, the tool info must be re-sent if
the tool changes.
- Tool info messages may not be sent in middle of drawing (between stroke info and
stroke end messages)
- Stroke info messages sent may not contain the same coordinates as the one
immediately preceded it.

\section synchronization Client synchronization

\b N is new client, \b O is one of the already existing clients.

Step 1) \b N joins session.
 - ... assumes it is out of sync.
 - ... blocks user as result.
 - ... waits for raster.
 - ... buffers any incoming stroke data. 

Step 2) Server announces user has joined session.
 - ... sends syncWait to all other clients.
 - ... sends join events for all already existing users to \b N
 - ... announces users who are active on this session. 

Step 3) Clients receive SyncWait message.
 - ... stop sending new stroke data.
   - ... but only after they've finished any ongoing stroke. 
 - ... reply with ACK/Sync
 - ... commit data received/ACK'd from network. 

Step 4) Server receives all ACK/Sync messages.
 - ... sends one Sync request to \b O.
 - ... sends ACK/Sync messages to all clients (except \b N).
 - ... adds \b N to data propagation 

Step 5) \b O receives Sync request.
 - ... ensures raster is up-to-date.
 - ... copies raster.
 - ... starts sending it to server with raster messages. 

Step 6) Clients receive ACK/Sync.
 - ... re-send Tool Info
 - ... and resume normal operation. 

Step 7) Server forwards raster data from \b O to \b N.

Step 8) \b N finishes retrieving raster.
 - ... commits buffered data.
 - ... unblocks user. 

@note
- In case there are no users in the session yet (and there's no local copy held of a persistent session's raster), server sends raster message with its payload completely zeroed.
- If the new client disconnects in middle of synchronization, server MAY send cancel message to the client providing the raster and resume as normal.
- If the client that's providing the raster disconnects, server goes back to sending syncwait to all clients and resumes synchronization. Alternatively, the server may have requested the raster from multiple clients to ensure at least one copy arrives within single syncronization event and send cancel to the one/s that provided it slower. Or - as it currently does - send error to waiting client/s and remove them from session, so they may rejoin and re-initiate client sync as normal.
- If another client joins while the synchronization is still in progress...
  - ... and we have not yet received all ACKs, the new client will join the list of waiting clients and join normal data propagation at the same moment the first one will.
  - ... otherwise, new client sync is initiated. 

\section persistent Persistent session caching

When session is made to persist (protocol::SessionEvent with action set to
protocol::SessionEvent::Persist), it may request the last user leaving (by
protocol::Unsubscribe) to provide the session raster data to cache. The client should
send the raster data, but is not required to. The client is not detached from session
before the raster is served, however, and will remain member of it until the raster is
served or the client is disconnected.

*/
